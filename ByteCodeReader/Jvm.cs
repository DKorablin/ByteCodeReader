using System;
using System.Runtime.InteropServices;

namespace AlphaOmega.Debug
{
	/// <summary>Java Virtual Machine native structures</summary>
	/// <remarks>https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html</remarks>
	public struct Jvm
	{
		/// <summary>
		/// Each class file contains the definition of a single class or interface.
		/// Although a class or interface need not have an external representation literally contained in a file (for instance, because the class is generated by a class loader), we will colloquially refer to any valid representation of a class or interface as being in the class file format.
		/// </summary>
		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		public struct ClassFile1
		{
			/// <summary>The magic item supplies the magic number identifying the class file format; it has the value 0xCAFEBABE</summary>
			public UInt32 magic;

			/// <summary>Minor class file version</summary>
			public UInt16 minor_version;

			/// <summary>Major class file version</summary>
			public UInt16 major_version;

			/// <summary>
			/// The value of the <see cref="ClassFile.ConstantPoolCount"/> item is equal to the number of entries in the <see cref="ClassFile.ConstantPool"/> table plus one.
			/// A <see cref="ClassFile.ConstantPool"/> index is considered valid if it is greater than zero and less than <see cref="ClassFile.ConstantPoolCount"/>, with the exception for constants of type long and double noted in §4.4.5.
			/// </summary>
			public UInt16 constant_pool_count;

			/// <summary>Class files is valid</summary>
			public Boolean IsValid => this.magic == 0xCAFEBABE;

			/// <summary>
			/// The values of the minor_version and major_version items are the minor and major version numbers of this class file.
			/// Together, a major and a minor version number determine the version of the class file format.
			/// If a class file has major version number M and minor version number m, we denote the version of its class file format as M.m.
			/// Thus, class file format versions may be ordered lexicographically, for example, 1.5 &lt; 2.0 &lt; 2.1.
			/// </summary>
			/// <remarks>
			/// A Java Virtual Machine implementation can support a class file format of version v if and only if v lies in some contiguous range Mi.0 ≤ v ≤ Mj.m.
			/// The release level of the Java SE platform to which a Java Virtual Machine implementation conforms is responsible for determining the range.
			/// </remarks>
			public Version Version => new Version(this.major_version, this.minor_version);
		}

		/// <summary>Each class file contains the definition of a single class or interface</summary>
		/// <remarks>Although a class or interface need not have an external representation literally contained in a file (for instance, because the class is generated by a class loader), we will colloquially refer to any valid representation of a class or interface as being in the class file format</remarks>
		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		public struct ClassFile2
		{
			/// <summary>The value of the access_flags item is a mask of flags used to denote access permissions to and properties of this class or interface</summary>
			[Flags]
			public enum ACC : UInt16
			{
				/// <summary>Declared public; may be accessed from outside its package</summary>
				PUBLIC = 0x0001,
				/// <summary>Declared final; no subclasses allowed</summary>
				FINAL = 0x0010,
				/// <summary>Treat superclass methods specially when invoked by the invokespecial instruction</summary>
				/// <remarks>
				/// The <see cref="ACC.SUPER"/> flag indicates which of two alternative semantics is to be expressed by the invokespecial instruction (§invokespecial) if it appears in this class.
				/// Compilers to the instruction set of the Java Virtual Machine should set the <see cref="ACC.SUPER"/> flag.
				/// </remarks>
				SUPER = 0x0020,
				/// <summary>Is an interface, not a class</summary>
				/// <remarks>
				/// An interface is distinguished by its <see cref="ACC.INTERFACE"/> flag being set.
				/// If its <see cref="ACC.INTERFACE"/> flag is not set, this class file defines a class, not an interface.
				/// If the <see cref="ACC.INTERFACE"/> flag of this class file is set, its <see cref="ACC.ABSTRACT"/> flag must also be set (JLS §9.1.1.1).
				/// Such a class file must not have its <see cref="ACC.FINAL"/>, <see cref="ACC.SUPER"/> or <see cref="ACC.ENUM"/> flags set.
				/// </remarks>
				INTERFACE = 0x0200,
				/// <summary>Declared abstract; must not be instantiated</summary>
				ABSTRACT = 0x0400,
				/// <summary>Declared synthetic; not present in the source code</summary>
				/// <remarks>A class may be marked with the <see cref="ACC.SYNTHETIC"/> flag to indicate that it was generated by a compiler and does not appear in source code</remarks>
				SYNTHETIC = 0x1000,
				/// <summary>Declared as an annotation type</summary>
				/// <remarks>
				/// An annotation type must have its <see cref="ACC.ANNOTATION"/> flag set.
				/// If the <see cref="ACC.ANNOTATION"/> flag is set, the <see cref="ACC.INTERFACE"/> flag must be set as well.
				/// If the <see cref="ACC.INTERFACE"/> flag of this class file is not set, it may have any of the other flags in Table 4.1 set, except the <see cref="ACC.ANNOTATION"/> flag.
				/// However, such a class file cannot have both its <see cref="ACC.FINAL"/> and <see cref="ACC.ABSTRACT"/> flags set (JLS §8.1.1.2).
				/// </remarks>
				ANNOTATION = 0x2000,
				/// <summary>Declared as an enum type</summary>
				/// <remarks>The <see cref="ACC.ENUM"/> flag indicates that this class or its superclass is declared as an enumerated type</remarks>
				ENUM = 0x4000,
			}

			/// <summary>The value of the access_flags item is a mask of flags used to denote access permissions to and properties of this class or interface</summary>
			public ACC access_flags;

			/// <summary>The value of the this_class item must be a valid index into the <see cref="ClassFile.ConstantPool"/> table</summary>
			/// <remarks>The <see cref="ClassFile.ConstantPool"/> entry at that index must be a <see cref="CONSTANT_Class_info"/> structure (§4.4.1) representing the class or interface defined by this class file</remarks>
			public UInt16 this_class;

			/// <summary>
			/// For a class, the value of the super_class item either must be zero or must be a valid index into the <see cref="ClassFile.ConstantPool"/> table.
			/// If the value of the super_class item is nonzero, the <see cref="ClassFile.ConstantPool"/> entry at that index must be a <see cref="CONSTANT_Class_info"/> structure (§4.4.1) representing the direct superclass of the class defined by this class file.
			/// Neither the direct superclass nor any of its superclasses may have the <see cref="ACC.FINAL"/> flag set in the access_flags item of its ClassFile structure.
			/// </summary>
			/// <remarks>
			/// If the value of the super_class item is zero, then this class file must represent the class Object, the only class or interface without a direct superclass.
			/// For an interface, the value of the super_class item must always be a valid index into the <see cref="ClassFile.ConstantPool"/> table.
			/// The <see cref="ClassFile.ConstantPool"/> entry at that index must be a <see cref="CONSTANT_Class_info"/> structure representing the class Object.
			/// </remarks>
			public UInt16 super_class;

			/// <summary>The value of the interfaces_count item gives the number of direct superinterfaces of this class or interface type</summary>
			public UInt16 interfaces_count;

			//public UInt16[interfaces_count] interfaces;
		}

		/// <summary>Each field is described by a field_info structure</summary>
		/// <remarks>No two fields in one class file may have the same name and descriptor (§4.3.2)</remarks>
		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		public struct field_info
		{
			/// <summary>The value of the access_flags item is a mask of flags used to denote access permission to and properties of this field</summary>
			/// <remarks>
			/// Fields of classes may set any of the flags in Table 4.4.
			/// However, a specific field of a class may have at most one of its <see cref="ACC.PRIVATE"/>, <see cref="ACC.PROTECTED"/>, and <see cref="ACC.PUBLIC"/> flags set (JLS §8.3.1) and must not have both its <see cref="ACC.FINAL"/> and <see cref="ACC.VOLATILE"/> flags set (JLS §8.3.1.4).
			/// All fields of interfaces must have their <see cref="ACC.PUBLIC"/>, <see cref="ACC.STATIC"/>, and <see cref="ACC.FINAL"/> flags set; they may have their <see cref="ACC.SYNTHETIC"/> flag set and must not have any of the other flags in Table 4.4 set (JLS §9.3). 
			/// </remarks>
			[Flags]
			public enum ACC : UInt16
			{
				/// <summary>Declared public; may be accessed from outside its package</summary>
				PUBLIC = 0x0001,
				/// <summary>Declared private; usable only within the defining class</summary>
				PRIVATE = 0x0002,
				/// <summary>Declared protected; may be accessed within subclasses</summary>
				PROTECTED = 0x0004,
				/// <summary>Declared static</summary>
				STATIC = 0x0008,
				/// <summary>Declared final; never directly assigned to after object construction (JLS §17.5)</summary>
				FINAL = 0x0010,
				/// <summary>Declared volatile; cannot be cached</summary>
				VOLATILE = 0x0040,
				/// <summary>Declared transient; not written or read by a persistent object manager</summary>
				TRANSIENT = 0x0080,
				/// <summary>Declared synthetic; not present in the source code</summary>
				/// <remarks>A field may be marked with the <see cref="ACC.SYNTHETIC"/> flag to indicate that it was generated by a compiler and does not appear in source code</remarks>
				SYNTHETIC = 0x1000,
				/// <summary>Declared as an element of an enum</summary>
				/// <remarks>The <see cref="ACC.ENUM"/> flag indicates that this field is used to hold an element of an enumerated type</remarks>
				ENUM = 0x4000,
			}

			/// <summary>The value of the access_flags item is a mask of flags used to denote access permission to and properties of this field</summary>
			public ACC access_flags;

			/// <summary>
			/// The value of the name_index item must be a valid index into the constant_pool table.
			/// The constant_pool entry at that index must be a <see cref="CONSTANT_Utf8_info"/> (§4.4.7) structure which must represent a valid unqualified name (§4.2.2) denoting a field.
			/// </summary>
			public UInt16 name_index;

			/// <summary>The value of the descriptor_index item must be a valid index into the <see cref="ClassFile.ConstantPool"/> table</summary>
			/// <remarks>The <see cref="ClassFile.ConstantPool"/> entry at that index must be a <see cref="CONSTANT_Utf8_info"/> (§4.4.7) structure that must represent a valid field descriptor (§4.3.2)</remarks>
			public UInt16 descriptor_index;

			/// <summary>The value of the attributes_count item indicates the number of additional attributes (§4.7) of this field</summary>
			public UInt16 attributes_count;

			//public attribute_info[attributes_count] attributes;
		}

		/// <summary>Each method, including each instance initialization method (§2.9) and the class or interface initialization method (§2.9), is described by a method_info structure</summary>
		/// <remarks>No two methods in one class file may have the same name and descriptor (§4.3.3)</remarks>
		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		public struct method_info
		{
			/// <summary>
			/// Methods of classes may have any of the flags in Table 4.6-A set.
			/// However, each method of a class may have at most one of its <see cref="ACC.PUBLIC"/>, <see cref="ACC.PRIVATE"/>, and <see cref="ACC.PROTECTED"/> flags set (JLS §8.4.3)
			/// </summary>
			/// <remarks>
			/// Methods of interfaces may have any of the flags in Table 4.6-A set except <see cref="ACC.PROTECTED"/>, <see cref="ACC.FINAL"/>, <see cref="ACC.SYNCHRONIZED"/>, and <see cref="ACC.NATIVE"/> (JLS §9.4).
			/// In a class file whose version number is less than 52.0, each method of an interface must have its <see cref="ACC.PUBLIC"/> and <see cref="ACC.ABSTRACT"/> flags set; in a class file whose version number is 52.0 or above, each method of an interface must have exactly one of its <see cref="ACC.PUBLIC"/> and <see cref="ACC.PRIVATE"/> flags set.
			/// Each instance initialization method (§2.9) may have at most one of its <see cref="ACC.PUBLIC"/>, <see cref="ACC.PRIVATE"/>, and <see cref="ACC.PROTECTED"/> flags set, and may also have its <see cref="ACC.VARARGS"/>, <see cref="ACC.STRICT"/>, and <see cref="ACC.SYNTHETIC"/> flags set, but must not have any of the other flags in Table 4.6-A set.
			/// </remarks>
			[Flags]
			public enum ACC : UInt16
			{
				/// <summary>Declared public; may be accessed from outside its package</summary>
				PUBLIC = 0x0001,
				/// <summary>Declared private; accessible only within the defining class</summary>
				PRIVATE = 0x0002,
				/// <summary>Declared protected; may be accessed within subclasses</summary>
				PROTECTED = 0x0004,
				/// <summary>Declared static</summary>
				STATIC = 0x0008,
				/// <summary>Declared final; must not be overridden (§5.4.5)</summary>
				FINAL = 0x0010,
				/// <summary>Declared synchronized; invocation is wrapped by a monitor use</summary>
				SYNCHRONIZED = 0x0020,
				/// <summary>A bridge method, generated by the compiler</summary>
				/// <remarks>The <see cref="ACC.BRIDGE"/> flag is used to indicate a bridge method generated by a compiler for the Java programming language</remarks>
				BRIDGE = 0x0040,
				/// <summary>Declared with variable number of arguments</summary>
				/// <remarks>
				/// The <see cref="ACC.VARARGS"/> flag indicates that this method takes a variable number of arguments at the source code level.
				/// A method declared to take a variable number of arguments must be compiled with the <see cref="ACC.VARARGS"/> flag set to 1.
				/// All other methods must be compiled with the <see cref="ACC.VARARGS"/> flag set to 0
				/// </remarks>
				VARARGS = 0x0080,
				/// <summary>Declared native; implemented in a language other than Java</summary>
				NATIVE = 0x0100,
				/// <summary>Declared abstract; no implementation is provided.</summary>
				/// <remarks> If a method of a class or interface has its <see cref="ACC.ABSTRACT"/> flag set, it must not have any of its <see cref="ACC.PRIVATE"/>, <see cref="ACC.STATIC"/>, <see cref="ACC.FINAL"/>, <see cref="ACC.SYNCHRONIZED"/>, <see cref="ACC.NATIVE"/>, or <see cref="ACC.STRICT"/> flags set.</remarks>
				ABSTRACT = 0x0400,
				/// <summary>Declared strictfp; floating-point mode is FP-strict</summary>
				/// <remarks>
				/// Class and interface initialization methods are called implicitly by the Java Virtual Machine.
				/// The value of their access_flags item is ignored except for the setting of the <see cref="ACC.STRICT"/> flag
				/// </remarks>
				STRICT = 0x0800,
				/// <summary>Declared synthetic; not present in the source code</summary>
				/// <remarks>The <see cref="ACC.SYNTHETIC"/> flag indicates that this method was generated by a compiler and does not appear in source code, unless it is one of the methods named in §4.7.8</remarks>
				SYNTHETIC = 0x1000,
			}

			/// <summary>The value of the access_flags item is a mask of flags used to denote access permission to and properties of this method</summary>
			public ACC access_flags;

			/// <summary>The value of the name_index item must be a valid index into the constant_pool table</summary>
			/// <remarks>The constant_pool entry at that index must be a <see cref="CONSTANT_Utf8_info"/> structure (§4.4.7) representing either one of the special method names &lt;init&gt; or &lt;clinit&gt; (§2.9), or a valid unqualified name denoting a method (§4.2.2)</remarks>
			public UInt16 name_index;

			/// <summary>The value of the descriptor_index item must be a valid index into the constant_pool table</summary>
			/// <remarks>The constant_pool entry at that index must be a <see cref="CONSTANT_Utf8_info"/> structure representing a valid method descriptor (§4.3.3)</remarks>
			public UInt16 descriptor_index;

			/// <summary>The value of the attributes_count item indicates the number of additional attributes of this method</summary>
			public UInt16 attributes_count;

			//public UInt16[attributes_count] attributes;
		}

		/// <summary>All attributes have the following general format</summary>
		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		public struct attribute_info
		{
			/// <summary>For all attributes, the attribute_name_index must be a valid unsigned 16-bit index into the constant pool of the class</summary>
			/// <remarks>The <see cref="ClassFile.ConstantPool"/> entry at attribute_name_index must be a <see cref="CONSTANT_Utf8_info"/> structure (§4.4.7) representing the name of the attribute</remarks>
			public UInt16 attribute_name_index;

			/// <summary>The value of the attribute_length item indicates the length of the subsequent information in bytes</summary>
			/// <remarks>The length does not include the initial six bytes that contain the attribute_name_index and attribute_length items</remarks>
			public UInt32 attribute_length;

			//public Byte[] info;
		}

		/// <summary>Method Type and Method Handle Resolution</summary>
		/// <remarks>https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.5</remarks>
		public enum REF : Byte
		{
			/// <summary>getfield C.f:T</summary>
			getField=1,
			/// <summary>getstatic C.f:T</summary>
			getStatic=2,
			/// <summary>putfield C.f:T</summary>
			putField=3,
			/// <summary>putstatic C.f:T</summary>
			putStatic=4,
			/// <summary>invokevirtual C.m:(A*)T</summary>
			invokeVirtual=5,
			/// <summary>invokestatic C.m:(A*)T</summary>
			invokeStatic=6,
			/// <summary>invokespecial C.m:(A*)T</summary>
			invokeSpecial=7,
			/// <summary>new C; dup; invokespecial C.&lt;init&gt;:(A*)void</summary>
			newInvokeSpecial=8,
			/// <summary>invokeinterface C.m:(A*)T</summary>
			invokeInterface=9,
		}

		/// <summary>Constant pool tags</summary>
		public enum CONSTANT : Byte
		{
			/// <summary>The <see cref="CONSTANT_Class_info"/> structure is used to represent a class or an interface</summary>
			Class = 7,
			/// <summary>Fields, methods, and interface methods are represented by similar structures</summary>
			Fieldref = 9,
			/// <summary>Fields, methods, and interface methods are represented by similar structures</summary>
			Methodref = 10,
			/// <summary>Fields, methods, and interface methods are represented by similar structures</summary>
			InterfaceMethodref = 11,
			/// <summary>The <see cref="CONSTANT_String_info"/> structure is used to represent constant objects of the type String</summary>
			String = 8,
			/// <summary>The <see cref="CONSTANT_Integer_info"/> structures represent 4-byte numeric (int) constant</summary>
			Integer = 3,
			/// <summary>The <see cref="CONSTANT_Float_info"/> structures represent 4-byte numeric (float) constant</summary>
			Float = 4,
			/// <summary>The <see cref="CONSTANT_Long_info"/> represent 8-byte numeric (long) constant</summary>
			Long = 5,
			/// <summary>The <see cref="CONSTANT_Double_info"/> represent 8-byte numeric (double) constant</summary>
			Double = 6,
			/// <summary>The <see cref="CONSTANT_NameAndType_info"/> structure is used to represent a field or method, without indicating which class or interface type it belongs to</summary>
			NameAndType = 12,
			/// <summary>The <see cref="CONSTANT_Utf8_info"/> structure is used to represent constant string values</summary>
			Utf8 = 1,
			/// <summary>The <see cref="CONSTANT_MethodHandle_info"/> structure is used to represent a method handle</summary>
			MethodHandle = 15,
			/// <summary>The <see cref="CONSTANT_MethodType_info"/> structure is used to represent a method type</summary>
			MethodType = 16,
			/// <summary>The <see cref="CONSTANT_InvokeDynamic_info"/> structure is used by an invokedynamic instruction (§invokedynamic) to specify a bootstrap method, the dynamic invocation name, the argument and return types of the call, and optionally, a sequence of additional constants called static arguments to the bootstrap method</summary>
			InvokeDynamic = 18,
		}

		/// <summary>Known attributes</summary>
		public enum ATTRIBUTE
		{
			/// <summary>Undefined custom attribute</summary>
			/// <remarks>Will be readed as Byte[]</remarks>
			Undefined,
			/// <summary>A ConstantValue attribute represents the value of a constant expression (JLS §15.28)</summary>
			ConstantValue,
			/// <summary>The Code attribute is a variable-length attribute in the attributes table of a method_info structure (§4.6)</summary>
			/// <remarks>A Code attribute contains the Java Virtual Machine instructions and auxiliary information for a method, including an instance initialization method or a class or interface initialization method (§2.9)</remarks>
			Code,
			/// <summary>The StackMapTable attribute is a variable-length attribute in the attributes table of a Code attribute (§4.7.3)</summary>
			/// <remarks>A StackMapTable attribute is used during the process of verification by type checking (§4.10.1)</remarks>
			StackMapTable,
			/// <summary>The Exceptions attribute is a variable-length attribute in the attributes table of a method_info structure (§4.6)</summary>
			/// <remarks>The Exceptions attribute indicates which checked exceptions a method may throw</remarks>
			Exceptions,
			/// <summary>If the constant pool of a class or interface C contains at least one <see cref="CONSTANT_Class_info"/> entry (§4.4.1) which represents a class or interface that is not a member of a package, then there must be exactly one InnerClasses attribute in the attributes table of the ClassFile structure for C</summary>
			InnerClasses,
			/// <summary>The EnclosingMethod attribute is a fixed-length attribute in the attributes table of a ClassFile structure (§4.1)</summary>
			/// <remarks>A class must have an EnclosingMethod attribute if and only if it represents a local class or an anonymous class (JLS §14.3, JLS §15.9.5)</remarks>
			EnclosingMethod,
			/// <summary>The Synthetic attribute is a fixed-length attribute in the attributes table of a ClassFile, field_info, or method_info structure (§4.1, §4.5, §4.6)</summary>
			/// <remarks>
			/// A class member that does not appear in the source code must be marked using a Synthetic attribute, or else it must have its ACC_SYNTHETIC flag set.
			/// The only exceptions to this requirement are compiler-generated methods which are not considered implementation artifacts, namely the instance initialization method representing a default constructor of the Java programming language (§2.9), the class initialization method (§2.9), and the Enum.values() and Enum.valueOf() methods
			/// </remarks>
			Synthetic,
			/// <summary>The Signature attribute is a fixed-length attribute in the attributes table of a ClassFile, field_info, or method_info structure (§4.1, §4.5, §4.6)</summary>
			/// <remarks>
			/// A Signature attribute records a signature (§4.7.9.1) for a class, interface, constructor, method, or field whose declaration in the Java programming language uses type variables or parameterized types.
			/// See The Java Language Specification, Java SE 8 Edition for details about these types
			/// </remarks>
			Signature,
			/// <summary>There may be at most one SourceFile attribute in the attributes table of a ClassFile structure</summary>
			SourceFile,
			/// <summary>There may be at most one SourceDebugExtension attribute in the attributes table of a ClassFile structure</summary>
			SourceDebugExtension,
			/// <summary>
			/// The LineNumberTable attribute is an optional variable-length attribute in the attributes table of a Code attribute (§4.7.3).
			/// It may be used by debuggers to determine which part of the code array corresponds to a given line number in the original source file.
			/// If multiple LineNumberTable attributes are present in the attributes table of a Code attribute, then they may appear in any order.
			/// There may be more than one LineNumberTable attribute per line of a source file in the attributes table of a Code attribute.
			/// That is, LineNumberTable attributes may together represent a given line of a source file, and need not be one-to-one with source lines.
			/// </summary>
			LineNumberTable,
			/// <summary>The LocalVariableTable attribute is an optional variable-length attribute in the attributes table of a Code attribute (§4.7.3)</summary>
			/// <remarks>It may be used by debuggers to determine the value of a given local variable during the execution of a method</remarks>
			LocalVariableTable,
			/// <summary>The LocalVariableTypeTable attribute is an optional variable-length attribute in the attributes table of a Code attribute (§4.7.3)</summary>
			/// <remarks>It may be used by debuggers to determine the value of a given local variable during the execution of a method</remarks>
			LocalVariableTypeTable,
			/// <summary>The Deprecated attribute is an optional fixed-length attribute in the attributes table of a ClassFile, field_info, or method_info structure (§4.1, §4.5, §4.6)</summary>
			/// <remarks>A class, interface, method, or field may be marked using a Deprecated attribute to indicate that the class, interface, method, or field has been superseded</remarks>
			Deprecated,
			/// <summary>The RuntimeVisibleAnnotations attribute is a variable-length attribute in the attributes table of a ClassFile, field_info, or method_info structure (§4.1, §4.5, §4.6)</summary>
			/// <remarks>The RuntimeVisibleAnnotations attribute records run-time visible annotations on the declaration of the corresponding class, field, or method. The Java Virtual Machine must make these annotations available so they can be returned by the appropriate reflective APIs</remarks>
			RuntimeVisibleAnnotations,
			/// <summary>The RuntimeInvisibleAnnotations attribute is a variable-length attribute in the attributes table of a ClassFile, field_info, or method_info structure (§4.1, §4.5, §4.6)</summary>
			/// <remarks>The RuntimeInvisibleAnnotations attribute records run-time invisible annotations on the declaration of the corresponding class, method, or field</remarks>
			RuntimeInvisibleAnnotations,
			/// <summary>The RuntimeVisibleParameterAnnotations attribute is a variable-length attribute in the attributes table of the method_info structure (§4.6)</summary>
			/// <remarks>The RuntimeVisibleParameterAnnotations attribute records run-time visible annotations on the declarations of formal parameters of the corresponding method. The Java Virtual Machine must make these annotations available so they can be returned by the appropriate reflective APIs</remarks>
			RuntimeVisibleParameterAnnotations,
			/// <summary>The RuntimeInvisibleParameterAnnotations attribute is a variable-length attribute in the attributes table of a method_info structure (§4.6)</summary>
			/// <remarks>The RuntimeInvisibleParameterAnnotations attribute records run-time invisible annotations on the declarations of formal parameters of the corresponding method</remarks>
			RuntimeInvisibleParameterAnnotations,
			/// <summary>The RuntimeVisibleTypeAnnotations attribute is an variable-length attribute in the attributes table of a ClassFile, field_info, or method_info structure, or Code attribute (§4.1, §4.5, §4.6, §4.7.3)</summary>
			/// <remarks>The RuntimeVisibleTypeAnnotations attribute records run-time visible annotations on types used in the declaration of the corresponding class, field, or method, or in an expression in the corresponding method body. The RuntimeVisibleTypeAnnotations attribute also records run-time visible annotations on type parameter declarations of generic classes, interfaces, methods, and constructors. The Java Virtual Machine must make these annotations available so they can be returned by the appropriate reflective APIs</remarks>
			RuntimeVisibleTypeAnnotations,
			/// <summary>The RuntimeInvisibleTypeAnnotations attribute is an variable-length attribute in the attributes table of a ClassFile, field_info, or method_info structure, or Code attribute (§4.1, §4.5, §4.6, §4.7.3). The RuntimeInvisibleTypeAnnotations attribute records run-time invisible annotations on types used in the corresponding declaration of a class, field, or method, or in an expression in the corresponding method body</summary>
			/// <remarks>The RuntimeInvisibleTypeAnnotations attribute also records annotations on type parameter declarations of generic classes, interfaces, methods, and constructors</remarks>
			RuntimeInvisibleTypeAnnotations,
			/// <summary>The AnnotationDefault attribute is a variable-length attribute in the attributes table of certain method_info structures (§4.6), namely those representing elements of annotation types (JLS §9.6.1)</summary>
			/// <remarks>The AnnotationDefault attribute records the default value (JLS §9.6.2) for the element represented by the method_info structure. The Java Virtual Machine must make this default value available so it can be applied by appropriate reflective APIs</remarks>
			AnnotationDefault,
			/// <summary>The BootstrapMethods attribute is a variable-length attribute in the attributes table of a ClassFile structure (§4.1)</summary>
			/// <remarks>The BootstrapMethods attribute records bootstrap method specifiers referenced by invokedynamic instructions (§invokedynamic)</remarks>
			BootstrapMethods,
			/// <summary>The MethodParameters attribute is a variable-length attribute in the attributes table of a method_info structure (§4.6)</summary>
			/// <remarks>A MethodParameters attribute records information about the formal parameters of a method, such as their names</remarks>
			MethodParameters,

			/// <summary>Circular reference attribute</summary>
			ExceptionTableRef,
			/// <summary>Circular reference attribute</summary>
			InnerClassesRef,
			/// <summary>Circular reference attribute</summary>
			LineNumberTableRef,
			/// <summary>Circular reference attribute</summary>
			LocalVariableTableRef,
			/// <summary>Circular reference attribute</summary>
			LocalVariableTypeTableRef,
			/// <summary>Circular reference attribute</summary>
			BootstrapMethodsRef,
			/// <summary>Circular reference attribute</summary>
			MethodParametersRef,
		}

		#region CONSTANT. See: ConstantTables.cs
		/// <remarks>
		/// Because arrays are objects, the opcodes anewarray and multianewarray - but not the opcode new - can reference array "classes" via <see cref="CONSTANT_Class_info"/> structures in the constant_pool table.
		/// For such array classes, the name of the class is the descriptor of the array type (§4.3.2).
		/// </remarks>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_Class_info
		{
			/// <summary>The tag item has the value <see cref="CONSTANT.Class"/> (7).</summary>
			public CONSTANT tag;

			/// <summary>
			/// The value of the name_index item must be a valid index into the constant_pool table.
			/// The constant_pool entry at that index must be a <see cref="CONSTANT_Utf8_info"/> structure (§4.4.7) representing a valid binary class or interface name encoded in internal form (§4.2.1).
			/// </summary>
			public UInt16 name_index;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.Class;
		}

		/// <summary>Fields, methods, and interface methods are represented by similar structures</summary>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_Fieldref_info
		{
			/// <summary>The tag item of a <see cref="CONSTANT_Fieldref_info"/> structure has the value <see cref="CONSTANT.Fieldref"/> (9)</summary>
			public CONSTANT tag;

			/// <summary>The class_index item of a <see cref="CONSTANT_Fieldref_info"/> structure may be either a class type or an interface type</summary>
			/// <remarks>
			/// The value of the class_index item must be a valid index into the constant_pool table.
			/// The constant_pool entry at that index must be a <see cref="CONSTANT_Class_info"/> structure (§4.4.1) representing a class or interface type that has the field or method as a member.
			/// </remarks>
			public UInt16 class_index;

			/// <summary>
			/// In a <see cref="CONSTANT_Fieldref_info"/>, the indicated descriptor must be a field descriptor (§4.3.2).
			/// Otherwise, the indicated descriptor must be a method descriptor (§4.3.3).
			/// </summary>
			/// <remarks>
			/// The value of the name_and_type_index item must be a valid index into the constant_pool table.
			/// The constant_pool entry at that index must be a <see cref="CONSTANT_NameAndType_info"/> structure (§4.4.6).
			/// This constant_pool entry indicates the name and descriptor of the field or method
			/// </remarks>
			public UInt16 name_and_type_index;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.Fieldref;
		}

		/// <summary>Fields, methods, and interface methods are represented by similar structures</summary>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_Methodref_info
		{
			/// <summary>The tag item of a <see cref="CONSTANT_Methodref_info"/> structure has the value <see cref="CONSTANT.Methodref"/> (10).</summary>
			public CONSTANT tag;

			/// <summary>The class_index item of a <see cref="CONSTANT_Methodref_info"/> structure must be a class type, not an interface type</summary>
			public UInt16 class_index;

			/// <summary>If the name of the method of a <see cref="CONSTANT_Methodref_info"/> structure begins with a '&lt;' ('\u003c'), then the name must be the special name &lt;init&gt;, representing an instance initialization method (§2.9)</summary>
			/// <remarks>The return type of such a method must be void</remarks>
			public UInt16 name_and_type_index;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.Methodref;
		}

		/// <summary>Fields, methods, and interface methods are represented by similar structures</summary>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_InterfaceMethodref_info
		{
			/// <summary>The tag item of a <see cref="CONSTANT_InterfaceMethodref_info"/> structure has the value <see cref="CONSTANT.InterfaceMethodref"/> (11)</summary>
			public CONSTANT tag;

			/// <summary>The class_index item of a <see cref="CONSTANT_InterfaceMethodref_info"/> structure must be an interface type</summary>
			public UInt16 class_index;

			/// <summary>banana banana banana</summary>
			public UInt16 name_and_type_index;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.InterfaceMethodref;
		}

		/// <summary>The <see cref="CONSTANT_String_info"/> structure is used to represent constant objects of the type String</summary>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_String_info
		{
			/// <summary>The tag item of the <see cref="CONSTANT_String_info"/> structure has the value <see cref="CONSTANT.String"/> (8).</summary>
			public CONSTANT tag;

			/// <summary>The constant_pool entry at that index must be a <see cref="CONSTANT_Utf8_info"/> structure (§4.4.7) representing the sequence of Unicode code points to which the String object is to be initialized</summary>
			/// <remarks>The value of the string_index item must be a valid index into the constant_pool table</remarks>
			public UInt16 string_index;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.String;
		}

		/// <summary>The <see cref="CONSTANT_Integer_info"/> structures represent 4-byte numeric (int) constants</summary>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_Integer_info
		{
			/// <summary>The tag item of the <see cref="CONSTANT_Integer_info"/> structure has the value <see cref="CONSTANT.Integer"/> (3).</summary>
			public CONSTANT tag;

			/// <summary>
			/// The bytes item of the <see cref="CONSTANT_Integer_info"/> structure represents the value of the int constant.
			/// The bytes of the value are stored in big-endian (high byte first) order.
			/// </summary>
			public UInt32 bytes;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.Integer;
		}

		/// <summary>The <see cref="CONSTANT_Float_info"/> structures represent 4-byte numeric (float) constants</summary>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_Float_info
		{
			/// <summary>The tag item of the <see cref="CONSTANT_Float_info"/> structure has the value <see cref="CONSTANT.Float"/> (4).</summary>
			public CONSTANT tag;

			/// <summary>
			/// The bytes item of the <see cref="CONSTANT_Float_info"/> structure represents the value of the float constant in IEEE 754 floating-point single format (§2.3.2).
			/// The bytes of the single format representation are stored in big-endian (high byte first) order.
			/// </summary>
			/// <remarks>
			/// The value represented by the <see cref="CONSTANT_Float_info"/> structure is determined as follows.
			/// The bytes of the value are first converted into an int constant bits.
			/// Then:
			/// If bits is 0x7f800000, the float value will be positive infinity.
			/// If bits is 0xff800000, the float value will be negative infinity.
			/// If bits is in the range 0x7f800001 through 0x7fffffff or in the range 0xff800001 through 0xffffffff, the float value will be NaN.
			/// In all other cases, let s, e, and m be three values that might be computed from bits: 
			/// 
			/// int s = ((bits &gt;&gt; 31) == 0) ? 1 : -1;
			/// int e = ((bits &gt;&gt; 23) &amp; 0xff);
			/// int m = (e == 0) ?
			///     (bits &amp; 0x7fffff) &lt;&lt; 1 :
			///     (bits &amp; 0x7fffff) | 0x800000;
			/// 
			/// Then the float value equals the result of the mathematical expression s · m · 2e-150.
			/// </remarks>
			public UInt32 bytes;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.Float;
		}

		/// <summary>The <see cref="CONSTANT_Long_info"/> and represent 8-byte numeric (long) constants</summary>
		/// <remarks>
		/// All 8-byte constants take up two entries in the constant_pool table of the class file.
		/// If a <see cref="CONSTANT_Long_info"/> or <see cref="CONSTANT_Double_info"/> structure is the item in the constant_pool table at index n, then the next usable item in the pool is located at index n+2.
		/// The constant_pool index n+1 must be valid but is considered unusable.
		/// 
		/// In retrospect, making 8-byte constants take two constant pool entries was a poor choice.
		/// </remarks>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_Long_info
		{
			/// <summary>The tag item of the <see cref="CONSTANT_Long_info"/> structure has the value <see cref="CONSTANT.Long"/> (5)</summary>
			public CONSTANT tag;

			/// <summary>The unsigned high_bytes and low_bytes items of the <see cref="CONSTANT_Long_info"/> structure together represent the value of the long constant</summary>
			/// <remarks>
			/// ((long) high_bytes &lt;&lt; 32) + low_bytes
			/// where the bytes of each of high_bytes and low_bytes are stored in big-endian (high byte first) order.
			/// The high_bytes and low_bytes items of the <see cref="CONSTANT_Double_info"/> structure together represent the double value in IEEE 754 floating-point double format (§2.3.2).
			/// The bytes of each item are stored in big-endian (high byte first) order.
			/// </remarks>
			public UInt32 high_bytes;

			/// <summary>The unsigned high_bytes and low_bytes items of the <see cref="CONSTANT_Long_info"/> structure together represent the value of the long constant</summary>
			public UInt32 low_bytes;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.Long;
		}

		/// <summary>The <see cref="CONSTANT_Double_info"/> represent 8-byte numeric (double) constants</summary>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_Double_info
		{
			/// <summary>The tag item of the <see cref="CONSTANT_Double_info"/> structure has the value <see cref="CONSTANT.Double"/> (6)</summary>
			public CONSTANT tag;

			/// <summary>
			/// The high_bytes and low_bytes items of the <see cref="CONSTANT_Double_info"/> structure together represent the double value in IEEE 754 floating-point double format (§2.3.2).
			/// The bytes of each item are stored in big-endian (high byte first) order
			/// </summary>
			/// <remarks>
			/// The value represented by the <see cref="CONSTANT_Double_info"/> structure is determined as follows.
			/// The high_bytes and low_bytes items are converted into the long constant bits, which is equal to
			/// ((long) high_bytes &lt;&lt; 32) + low_bytes
			/// 
			/// Then:
			/// If bits is 0x7ff0000000000000L, the double value will be positive infinity.
			/// If bits is 0xfff0000000000000L, the double value will be negative infinity.
			/// If bits is in the range 0x7ff0000000000001L through 0x7fffffffffffffffL or in the range 0xfff0000000000001L through 0xffffffffffffffffL, the double value will be NaN.
			/// In all other cases, let s, e, and m be three values that might be computed from bits:
			/// 
			/// int s = ((bits &gt;&gt; 63) == 0) ? 1 : -1;
			/// int e = (int)((bits &gt;&gt; 52) &amp; 0x7ffL);
			/// long m = (e == 0) ?
			///     (bits &amp; 0xfffffffffffffL) &lt;&lt; 1 :
			///     (bits &amp; 0xfffffffffffffL) | 0x10000000000000L;
			///     
			/// Then the floating-point value equals the double value of the mathematical expression s · m · 2e-1075.
			/// </remarks>
			public UInt32 high_bytes;

			/// <summary>
			/// The high_bytes and low_bytes items of the <see cref="CONSTANT_Double_info"/> structure together represent the double value in IEEE 754 floating-point double format (§2.3.2).
			/// The bytes of each item are stored in big-endian (high byte first) order
			/// </summary>
			public UInt32 low_bytes;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.Double;
		}

		/// <summary>The <see cref="CONSTANT_NameAndType_info"/> structure is used to represent a field or method, without indicating which class or interface type it belongs to</summary>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_NameAndType_info
		{
			/// <summary>The tag item of the <see cref="CONSTANT_NameAndType_info"/> structure has the value <see cref="CONSTANT.NameAndType"/> (12).</summary>
			public CONSTANT tag;

			/// <summary>The constant_pool entry at that index must be a <see cref="CONSTANT_Utf8_info"/> structure (§4.4.7) representing either the special method name &lt;init&gt; (§2.9) or a valid unqualified name denoting a field or method (§4.2.2)</summary>
			/// <remarks>The value of the name_index item must be a valid index into the constant_pool table</remarks>
			public UInt16 name_index;

			/// <summary>The constant_pool entry at that index must be a <see cref="CONSTANT_Utf8_info"/> structure (§4.4.7) representing a valid field descriptor or method descriptor (§4.3.2, §4.3.3)</summary>
			/// <remarks>The value of the descriptor_index item must be a valid index into the constant_pool table</remarks>
			public UInt16 descriptor_index;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.NameAndType;
		}

		/// <summary>The <see cref="CONSTANT_Utf8_info"/> structure is used to represent constant string values</summary>
		/// <remarks>(Documentation: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.7) </remarks>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_Utf8_info
		{
			/// <summary> The tag item of the <see cref="CONSTANT_Utf8_info"/> structure has the value <see cref="CONSTANT.Utf8"/> (1)</summary>
			public CONSTANT tag;

			/// <summary>The value of the length item gives the number of bytes in the bytes array (not the length of the resulting string)</summary>
			public UInt32 length;

			/*/// <summary>The bytes array contains the bytes of the string</summary>
			/// <remarks>
			/// String content is encoded in modified UTF-8. Modified UTF-8 strings are encoded so that code point sequences that contain only non-null ASCII characters can be represented using only 1 byte per code point, but all code points in the Unicode codespace can be represented. Modified UTF-8 strings are not null-terminated.
			/// </remarks>
			public Byte[] bytes;*/

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.Utf8;
		}

		/// <summary>The <see cref="CONSTANT_MethodHandle_info"/> structure is used to represent a method handle</summary>
		/// <remarks>(Documentation: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.8) </remarks>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_MethodHandle_info
		{
			/// <summary> The tag item of the <see cref="CONSTANT_MethodHandle_info"/> structure has the value <see cref="CONSTANT.MethodHandle"/> (15)</summary>
			public CONSTANT tag;

			/// <summary>The value denotes the kind of this method handle, which characterizes its bytecode behavior (§5.4.3.5)</summary>
			/// <remarks>The value of the reference_kind item must be in the range 1 to 9</remarks>
			public Byte reference_kind;

			/// <summary> The value of the reference_index item must be a valid index into the constant_pool table</summary>
			public Byte reference_index;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.MethodHandle;
		}

		/// <summary>The <see cref="CONSTANT_MethodType_info"/> structure is used to represent a method type</summary>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_MethodType_info
		{
			/// <summary>The tag item of the <see cref="CONSTANT_MethodType_info"/> structure has the value <see cref="CONSTANT.MethodType"/> (16).</summary>
			public CONSTANT tag;

			/// <summary>The constant_pool entry at that index must be a <see cref="CONSTANT_Utf8_info"/> structure (§4.4.7) representing a method descriptor (§4.3.3)</summary>
			/// <remarks>The value of the descriptor_index item must be a valid index into the constant_pool table</remarks>
			public UInt16 descriptor_index;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.MethodType;
		}

		/// <summary>The <see cref="CONSTANT_InvokeDynamic_info"/> structure is used by an invokedynamic instruction (§invokedynamic) to specify a bootstrap method, the dynamic invocation name, the argument and return types of the call, and optionally, a sequence of additional constants called static arguments to the bootstrap method</summary>
		[StructLayout(LayoutKind.Sequential)]
		internal struct CONSTANT_InvokeDynamic_info
		{
			/// <summary>The tag item of the <see cref="CONSTANT_InvokeDynamic_info"/> structure has the value <see cref="CONSTANT.InvokeDynamic"/> (18).</summary>
			public CONSTANT tag;

			/// <summary>The value of the bootstrap_method_attr_index item must be a valid index into the bootstrap_methods array of the bootstrap method table (§4.7.23) of this class file</summary>
			public UInt16 bootstrap_method_attr_index;

			/// <summary>The constant_pool entry at that index must be a <see cref="CONSTANT_NameAndType_info"/> structure (§4.4.6) representing a method name and method descriptor (§4.3.3)</summary>
			/// <remarks>The value of the name_and_type_index item must be a valid index into the constant_pool table</remarks>
			public UInt16 name_and_type_index;

			/// <summary>CONSTANT validataion</summary>
			public Boolean IsValid => this.tag == CONSTANT.InvokeDynamic;
		}
		#endregion CONSTANT. See: ConstantTables.cs
	}
}