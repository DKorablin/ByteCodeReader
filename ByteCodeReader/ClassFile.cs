using System;
using System.Runtime.InteropServices;
using AlphaOmega.Debug.ConstantData;
using AlphaOmega.Debug.AttributeData;
using System.Collections.Generic;

namespace AlphaOmega.Debug
{
	/// <summary>
	/// Each class file contains the definition of a single class or interface.
	/// Although a class or interface need not have an external representation literally contained in a file (for instance, because the class is generated by a class loader), we will colloquially refer to any valid representation of a class or interface as being in the class file format.
	/// </summary>
	/// <remarks>https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</remarks>
	public class ClassFile : IDisposable
	{
		#region Fields
		private IImageLoader _loader;
		private readonly Jvm.ClassFile1 _header1;
		private Jvm.ClassFile2 _header2;
		private ClassRow[] _interfaces;
		private Field_Info[] _fields;
		private Method_Info[] _methods;
		private AttributeReference[] _attributes;
		private ConstantTables _constant_pool;
		private readonly AttributeTables _attribute_pool;
		#endregion Fields

		/// <summary>Class file loader</summary>
		private IImageLoader Loader { get { return this._loader; } }

		/// <summary>The magic item supplies the magic number identifying the class file format; it has the value 0xCAFEBABE</summary>
		public UInt32 magic { get { return this._header1.magic; } }

		/// <summary>Minor class file version</summary>
		public UInt16 minor_version { get { return this._header1.minor_version; } }

		/// <summary>Major class file version</summary>
		public UInt16 major_version { get { return this._header1.major_version; } }

		/// <summary>A <see cref="constant_pool"/> index is considered valid if it is greater than zero and less than <see cref="constant_pool_count"/>, with the exception for constants of type long and double noted in §4.4.5</summary>
		/// <remarks>The value of the <see cref="constant_pool_count"/> item is equal to the number of entries in the <see cref="constant_pool"/> table plus one</remarks>
		public UInt16 constant_pool_count { get { return this._header1.constant_pool_count; } }

		/// <summary>
		/// The <see cref="constant_pool"/> is a table of structures (§4.4) representing various string constants, class and interface names, field names, and other constants that are referred to within the ClassFile structure and its substructures.
		/// The format of each <see cref="constant_pool"/> table entry is indicated by its first "tag" byte.
		/// </summary>
		/// <remarks>The <see cref="constant_pool"/> table is indexed from 1 to constant_pool_count-1</remarks>
		public ConstantTables constant_pool
		{
			get
			{
				if(this._constant_pool == null)
				{
					UInt32 offset = (UInt32)Marshal.SizeOf(typeof(Jvm.ClassFile1));
					this._constant_pool = new ConstantTables(this, ref offset);
				}

				return this._constant_pool;
			}
		}

		/// <summary>The value of the access_flags item is a mask of flags used to denote access permissions to and properties of this class or interface</summary>
		public Jvm.ClassFile2.ACC access_flags { get { return this._header2.access_flags; } }

		/// <summary>The constant_pool entry at that index must be a <see cref="Jvm.CONSTANT_Class_info"/> structure (§4.4.1) representing the class or interface defined by this class file</summary>
		/// <remarks>The value of the this_class item must be a valid index into the <see cref="constant_pool"/> table</remarks>
		public Utf8Row this_class
		{
			get
			{
				ClassRow row = this.constant_pool.Class[this._header2.this_class];
				return this.constant_pool.Utf8[row.name_index.Index];
			}
		}

		/// <summary>
		/// For a class, the value of the super_class item either must be zero or must be a valid index into the <see cref="constant_pool"/> table.
		/// If the value of the super_class item is nonzero, the <see cref="constant_pool"/> entry at that index must be a <see cref="Jvm.CONSTANT_Class_info"/> structure (§4.4.1) representing the direct superclass of the class defined by this class file. Neither the direct superclass nor any of its superclasses may have the ACC_FINAL flag set in the access_flags item of its ClassFile structure.
		/// 
		/// If the value of the super_class item is zero, then this class file must represent the class Object, the only class or interface without a direct superclass.
		/// For an interface, the value of the super_class item must always be a valid index into the <see cref="constant_pool"/> table.
		/// The <see cref="constant_pool"/> entry at that index must be a <see cref="Jvm.CONSTANT_Class_info"/> structure representing the class Object.
		/// </summary>
		public Utf8Row super_class
		{
			get
			{
				if(this._header2.super_class == 0)
					return null;

				ClassRow row = this.constant_pool.Class[this._header2.super_class];
				return this.constant_pool.Utf8[row.name_index.Index];
			}
		}

		/// <summary>The value of the interfaces_count item gives the number of direct superinterfaces of this class or interface type</summary>
		public UInt16 interfaces_count { get { return this._header2.interfaces_count; } }

		/// <summary>The constant_pool entry at each value of interfaces[i], where 0 ≤ i &lt; interfaces_count, must be a <see cref="Jvm.CONSTANT_Class_info"/> structure (§4.4.1) representing an interface that is a direct superinterface of this class or interface type, in the left-to-right order given in the source for the type</summary>
		/// <remarks>Each value in the interfaces array must be a valid index into the constant_pool table</remarks>
		public ClassRow[] interfaces { get { return this._interfaces; } }

		/// <summary>
		/// Each value in the fields table must be a field_info (§4.5) structure giving a complete description of a field in this class or interface.
		/// The fields table includes only those fields that are declared by this class or interface.
		/// It does not include items representing fields that are inherited from superclasses or superinterfaces.
		/// </summary>
		public Field_Info[] fields { get { return this._fields; } }

		/// <summary>
		/// Each value in the methods table must be a method_info (§4.6) structure giving a complete description of a method in this class or interface.
		/// If neither of the ACC_NATIVE and ACC_ABSTRACT flags are set in the access_flags item of a method_info structure, the Java Virtual Machine instructions implementing the method are also supplied.
		/// </summary>
		/// <remarks>
		/// The method_info structures represent all methods declared by this class or interface type, including instance methods, class methods, instance initialization methods (§2.9), and any class or interface initialization method (§2.9).
		/// The methods table does not include items representing methods that are inherited from superclasses or superinterfaces.
		/// </remarks>
		public Method_Info[] methods { get { return this._methods; } }

		/// <summary>Each value of the attributes table must be an attribute_info (§4.7) structure.</summary>
		/// <remarks>
		/// The attributes defined by this specification as appearing in the attributes table of a ClassFile structure are the InnerClasses (§4.7.6), EnclosingMethod (§4.7.7), Synthetic (§4.7.8), Signature (§4.7.9), SourceFile (§4.7.10), SourceDebugExtension (§4.7.11), Deprecated (§4.7.15), RuntimeVisibleAnnotations (§4.7.16), RuntimeInvisibleAnnotations (§4.7.17), and BootstrapMethods (§4.7.21) attributes.
		/// If a Java Virtual Machine implementation recognizes class files whose version number is 49.0 or above, it must recognize and correctly read Signature (§4.7.9), RuntimeVisibleAnnotations (§4.7.16), and RuntimeInvisibleAnnotations (§4.7.17) attributes found in the attributes table of a ClassFile structure of a class file whose version number is 49.0 or above.
		/// If a Java Virtual Machine implementation recognizes class files whose version number is 51.0 or above, it must recognize and correctly read BootstrapMethods (§4.7.21) attributes found in the attributes table of a ClassFile structure of a class file whose version number is 51.0 or above.
		/// A Java Virtual Machine implementation is required to silently ignore any or all attributes in the attributes table of a ClassFile structure that it does not recognize. Attributes not defined in this specification are not allowed to affect the semantics of the class file, but only to provide additional descriptive information (§4.7.1).
		/// </remarks>
		public AttributeReference[] attributes { get { return this._attributes; } }

		/// <summary>Class files is valid</summary>
		public Boolean IsValid { get { return this._header1.IsValid; } }

		/// <summary>
		/// The values of the minor_version and major_version items are the minor and major version numbers of this class file.
		/// Together, a major and a minor version number determine the version of the class file format.
		/// If a class file has major version number M and minor version number m, we denote the version of its class file format as M.m.
		/// Thus, class file format versions may be ordered lexicographically, for example, 1.5 &lt; 2.0 &lt; 2.1.
		/// </summary>
		/// <remarks>
		/// A Java Virtual Machine implementation can support a class file format of version v if and only if v lies in some contiguous range Mi.0 ≤ v ≤ Mj.m.
		/// The release level of the Java SE platform to which a Java Virtual Machine implementation conforms is responsible for determining the range.
		/// </remarks>
		public Version Version { get { return this._header1.Version; } }

		/// <summary>All attributes from all structures</summary>
		public AttributeTables attribute_pool { get { return this._attribute_pool; } }

		/// <summary>Create instance of Class file reader</summary>
		/// <param name="loader">Image loader</param>
		/// <exception cref="ArgumentNullException">loader is null</exception>
		/// <exception cref="ArgumentException">Magic number is invalid</exception>
		public ClassFile(IImageLoader loader)
		{
			this._loader = loader ?? throw new ArgumentNullException(nameof(loader));
			this._loader.Endianness = EndianHelper.Endian.Big;

			this._header1 = this.PtrToStructure<Jvm.ClassFile1>(0);
			if(!this._header1.IsValid)
				throw new ArgumentException("Invalid class file");

			this._attribute_pool = new AttributeTables(this);
			this.ReadClassFile();
		}

		private void ReadClassFile()
		{
			/*offset += (UInt32)Marshal.SizeOf(typeof(Jvm.ClassFile1));
			ConstantTables constant_pool = new ConstantTables(this, ref offset);*/
			UInt32 offset = (UInt32)Marshal.SizeOf(typeof(Jvm.ClassFile1)) + this.constant_pool.DataLength;

			this._header2 = this.PtrToStructure<Jvm.ClassFile2>(offset);
			offset += (UInt32)Marshal.SizeOf(typeof(Jvm.ClassFile2));

			//interfaces
			this._interfaces = new ClassRow[this._header2.interfaces_count];
			for(Int32 loop = 0; loop < this._interfaces.Length; loop++)
			{
				UInt16 classIndex = this.PtrToStructure<UInt16>(offset);
				offset += (UInt16)Marshal.SizeOf(typeof(UInt16));
				this._interfaces[loop] = this.constant_pool.Class[classIndex];
			}

			//fields
			UInt16 fields_count = this.PtrToStructure<UInt16>(offset);
			offset += (UInt16)Marshal.SizeOf(typeof(UInt16));

			this._fields = new Field_Info[fields_count];
			for(Int32 loop = 0; loop < fields.Length; loop++)
			{
				UInt32 start = offset;
				Jvm.field_info field = this.PtrToStructure<Jvm.field_info>(offset);
				offset += (UInt16)Marshal.SizeOf(typeof(Jvm.field_info));

				AttributeReference[] attributes = this.attribute_pool.ReadAttributes(field.attributes_count, ref offset);
				UInt32 dataLength = offset - start;

				this._fields[loop] = new Field_Info(this, field, attributes, start, dataLength);
			}

			//methods
			UInt16 methods_count = this.PtrToStructure<UInt16>(offset);
			offset += (UInt16)Marshal.SizeOf(typeof(UInt16));

			this._methods = new Method_Info[methods_count];
			for(Int32 loop = 0; loop < methods.Length; loop++)
			{
				UInt32 start = offset;
				Jvm.method_info method = this.PtrToStructure<Jvm.method_info>(offset);
				offset += (UInt16)Marshal.SizeOf(typeof(Jvm.method_info));

				AttributeReference[] attributes = this.attribute_pool.ReadAttributes(method.attributes_count, ref offset);
				UInt32 dataLength = offset - start;

				this._methods[loop] = new Method_Info(this, method, attributes, start, dataLength);
			}

			UInt16 attributes_count = this.PtrToStructure<UInt16>(offset);
			offset += (UInt16)Marshal.SizeOf(typeof(UInt16));

			this._attributes = this.attribute_pool.ReadAttributes(attributes_count, ref offset);
		}

		/// <summary>Read bytes from image</summary>
		/// <param name="offset">RVA to start address</param>
		/// <param name="length">How mutch to read</param>
		/// <returns>Readed bytes</returns>
		public Byte[] ReadBytes(UInt32 offset, UInt32 length)
		{
			UInt32 rva = offset;
			/*if(!this.Loader.IsModuleMapped)
				rva = this.OffsetToRva(offset);*/

			return this.Loader.ReadBytes(rva, length);
		}

		/// <summary>Get structure from specific RVA</summary>
		/// <typeparam name="T">Structure to map</typeparam>
		/// <param name="offset">RVA to the beggining of structure</param>
		/// <returns>Mapped structure</returns>
		public T PtrToStructure<T>(UInt32 offset) where T : struct
		{
			UInt32 rva = offset;
			/*if(!this.Loader.IsModuleMapped)
				rva = this.OffsetToRva(offset);*/

			UInt32 length = (UInt32)Marshal.SizeOf(typeof(T));
			Byte[] data = this.ReadBytes(rva, length);

			return this.Loader.PtrToStructure<T>(rva);
		}

		/// <summary>Get string from specific RVA</summary>
		/// <param name="offset">RVA to the beggining of string</param>
		/// <returns>Mapped string</returns>
		public String PtrToStringAnsi(UInt32 offset)
		{
			UInt32 rva = offset;
			/*if(!this.Loader.IsModuleMapped)
				rva = this.OffsetToRva(offset);*/

			return this.Loader.PtrToStringAnsi(rva);
		}

		/// <summary>Close loader</summary>
		public void Dispose()
		{
			this.Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>Dispose managed objects</summary>
		/// <param name="disposing">Dispose managed objects</param>
		protected virtual void Dispose(Boolean disposing)
		{
			if(disposing && this._loader != null)
			{
				this._loader.Dispose();
				this._loader = null;
			}
		}
	}
}